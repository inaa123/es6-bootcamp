<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        /*
        es6(ECMAScript6) = 2016년에 나온 자바스크립트의 버전
        - 변수가 추가 let, const(var는 사용하지 않도록 권장)
        - 함수의 작성법이 추가됨(화살표 함수)
        - 새로운 문법(문법이 좀 바뀜)(템플릿 리터럴)
        - 새로운 메서드 추가

        react와 같은 새로운 라이브러리가 es6문법에 최적화 되어 있으므로 리액트를 배우기 위해서는 es6가 선행되어야 한다.

        변수가 생성되는 과정
        1.선언 단계
        - 변수를 실행하고 / 함수에 등록하는 과정이다.
        2. 초기화 과정
        - 변수명 안에 값이 들어갈 경우 공간을 만들기 위해서 영역을 확보하는 단계다.
        이 단계에서는 undefined가 출력됨

        3. 값의 할당
        - undefined로 초기화된 변수에 값이 들어감.

        var는 1번과 2번을 동시에 실행하기 때문에 변수를 등록하고 공간을 확보하는 과정에서 값을 참조하려 하기 때문에 변수를 선언하기 전에 값을 호출해도 에러가 아닌 undefined를 출력한다. 
        이 현상을 변수 호이스팅이라고 한다.

        let과 const는 다른 프로그래밍 언어와 같은 블록레벨 스코프 단위의 변수 키워드다.

        변수 스코프의 종류
        -블록레벨 스코프(if, for, while)에서 선언되는 변수는 블록내에서만 유효한 변수여야 한다. 밖에서는 호출할 수 없다.
        블록레벨 내에서 선언되는 변수는 모두 지역변수이다.
        
        -함수레벨 스코프(var)
        함수 내에서 선언된 변수는 함수 내에서만 사용하며, 함수 밖으로 호출할 수 없다. 함수 내에서 선언된 변수는 모두 지역변수, 밖에서 선언된 변수는 모두 전역변수다.

        함수레벨 스코프의 단점
        -범위를 예측하기 어려워짐 = 사용범위가 넓어짐(오류의 범위도 넓어진다)
            보통 변수 등 사용할 땐 예측가능한 블럭범위 내에서만 사용하는 게 좋다.(오류발견하기 쉬움.)
        -전역변수보다 지역변수의 사용이 적어질 수도 있다.
        -호이스팅 문제가 많이 발생한다.
        =>이런 문제를 막기위해 블록레벨스코프의 변수 let,const등장

        let, const 블록레벨 변수 스코프

        let:
        재선언은 불가능, 값의 재할당은 가능
        호이스팅이 불가능

        const:
        재선언 불가능, 값의 재할당도 불가능
        호이스팅 불가능
        값이 변하지 않는 상수를 많이 할당한다.
        보통적으로 값이 변하는 경우가 많이 없기 때문에 const를 기본적으로 할당 후 let으로 변경하는 방법이 좋다.
        
        */
        function test01(){
            var testText = 'text';
            if(true){
                var testText02 = 'text02';
            }
            console.log(testText);
            console.log(testText02);
        }
        test01();

        function test02(){
            if(true){
                let testText03 = 'text03';
                const testText04 = 'text04';
            }
            console.log(testText03);
            console.log(testText04);
        }
        test02();
    </script>
</head>
<body>
    
</body>
</html>